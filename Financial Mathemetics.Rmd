---
title: "Financial mathematics"
author: "Yusuf Tatlier"
output: html_document
---

## H1: Theoretical background

## Measure and probability space

A measure space is a triple $(X,\mathcal{A},\mu)$ in which

- $X$ is a set
- $\mathcal{A}$ is a sigma-algebra on $X$, which means that it is a set of subsets of $X$ satisfying the following three properties:

    + $X$ is in $\mathcal{A}$

    + If $A \in \mathcal{A}$, then $X \setminus \mathcal{A} \in \mathcal{A}$

    + If elements of a sequence $\{A_i\}$ are all in $\mathcal{A}$, then $\cup_{i=1}^{\infty}A_i \in \mathcal{A}$ 
- $\mu$ is a function with $\mathcal{A} \rightarrow \mathbb{R}$ that satisfies the following properties:
    + $\forall A \in \mathcal{A}$ it will hold $\mu(A) \geq 0$
    + $\mu(\emptyset)=0$
    + If elements of a sequence $\{A_i\}$ are all in $\mathcal{A}$, then $\mu(\cup_{i=1}^{\infty}A_i) = \sum_{i=1}^{\infty}\mu(A_i)$ 

A probability space $(\Omega,\mathcal{F},\mathbb{P})$ is basically a measure space in which $\mathbb{P}:\mathcal{F} \rightarrow [0,1]$ and $\mathbb{P}(\Omega)=1$.
A random variable $X$ on such a space is defined as a measurable function with $\Omega \rightarrow \mathbb{R}$, which means that for any open set $B \subset \mathbb{R}$, the pre-image of this set under $X$ lies in $\Omega$, i.e. $X^{-1}(B) \in \mathcal{F}$. 
The probability that $X$ takes on a value in $B$ is then given by:
$$\mathbb{P}(X \in B) = \mathbb{P}(\omega \in A|X(\omega) \in B)$$

## Filtrations and martingales

A stochastic process $(X_t)$ is sequence of (discrete or continuous) random variables on a certain probability space $(\Omega,\mathcal{F},P)$. Here the sigma-algebra $\mathcal{F}$ is basically a collection of all events on the probability space. 
A filtration $(\mathcal{F}_t)$ is an increasing sequence of sigma-algebras. In specific, in case a filtration is generated by a stochastic process $(X_t)$, it is denoted as $\mathcal{F}_t=\sigma(X_t)$ and is also called the natural filtration. We say that a filtration $(\mathcal{F}_t)$ is adapted to $(X_t)$ if $\sigma(X_t) \subset \mathcal{F}_t$.

Filtrations are used in order to model an information flow. The natural filtration for example contains all information on the path of the stochastic process until that time, while information on the future is unknown. In specific a process $(X_t)$ is said to be predictable if it holds that $\sigma(X_t) \subset \mathcal{F}_{\tau}$  for $\tau < t$.

A stochastic process $(X_t)$ is said to be a martingale in case $E(X_t|\mathcal{F_\tau})=X_\tau$ for $\tau<t$. This means that the expectation of stochastic process in the future is its current value.

The stock price $(S_t)$ is a stochastic process. In the risk-neutral valuation of the contracts it will be seen that for the random variable $\tilde{S}_t=e^{-rt}S_t$ it holds that:
$$  E(\tilde{S}_t|\mathcal{F_t})=\tilde{S}_{t} $$

## (Symmetric) Random walk and Brownian motion

Define a discrete stochastic process $(X_n)$ as a sequence of Bernoulli random variables with $p=0.5$. Now define the random walk $(Z_n)$ as $Z_n=\sum_{i=1}^{n}X_i$. 
Note that the random walk is a martingale as $E(Z_{n+1}|\mathcal{F}_n)=Z_n$, where $(\mathcal{F}_n)$ is the natural filtration of $(Z_n)$.

A continuous equivalent of this process can be derived by increasing the number of steps per time unit and adjust the step size accordingly: We look at $\frac{1}{\delta}$  number of steps per time unit and set the step size to $\sqrt{\delta}$. This means that the Brownian motion $(B_t)$ is obtained as a limiting case of the following process:
$$  \frac{1}{\sqrt{\delta}}\sum_{i=1}^{n\delta}Z_i   $$
Note that this walk has a mean zero and a variance of $t=n \delta$:

```{r}
random_walk=function(N,sim,delta,total_steps){
  step=sqrt(delta)
  bern_var=replicate(sim,sample(c(-step,step),size=total_steps,prob=c(0.5,0.5),replace=TRUE))
  rw_path=apply(bern_var,2,cumsum)
  return(rw_path)
}

steps_per_unit=100
N=20

delta=(1/steps_per_unit)
total_steps=N*steps_per_unit
time=delta*(1:total_steps)
path_1=random_walk(20,1,delta,total_steps)
plot(time,path_1,type='l',main="Random walk",xlab="time",ylab="value")

```

## Variation and quadratic variation of functions

The variation measures the amount of change of a function (over a certain interval). More specifically if we partition the interval $[0,T]$ using the following sequence of $n$ points $0=x_1<x_2<...<x_{n}=T$, the variation of the function $f:\mathbb{R} \rightarrow \mathbb{R}$ over this interval is defined as the limiting case of the sum $\sum_i |f(x_{i+1})-f(x_i)|$.

By the definition of the derivative we can rewrite $|f(x_{i+1})-f(x_i)|$ as $|f(x_{i})|\times \Delta x$, assuming fixed distances between the $x_i$ and so $\Delta x=x_{i+1}-x_i$. Note that in the limit, this sum converges to $\int_{a}^{b} |f'(x)|dx$. This sum will be non-zero for non-constant (differentiable) functions.

The quadratric variation is given by the limiting case of the sum $\sum_i |f(x_{i+1})-f(x_i)|^2$. For differentiable functions, this sum will go to zero. Similarly this notion can be extended to p-variation for larger values of $p$.

Below we show some examples. 

```{r}
variation=function(start_val,end_val,n,val_fun){
    
  total_var=0
  dx=(end_val-start_val)/n
  new_val=start_val
  
    for(i in 1:n){
      total_var = total_var+abs(val_fun(new_val+dx)-val_fun(new_val))
      new_val = new_val + dx
    }
      return(total_var)    
}

quad_variation=function(start_val,end_val,n,val_fun){
    
  total_var=0
  dx=(end_val-start_val)/n
  new_val=start_val
  
    for(i in 1:n){
      total_var = total_var+(val_fun(new_val+dx)-val_fun(new_val))^2
      new_val = new_val + dx
    }
      return(total_var)    
}

var_fun1=variation(1,2,100,function(y){return(y^2)})
var_fun2=variation(1,2,100,function(y){return(sin(y))})

x_vector=seq(100,10000,100)
quad_var_y2=function(x){return(quad_variation(1,2,x,function(y){return(y^2)}))}
plot(x_vector,sapply(x_vector,quad_var_y2),type="l",main="quadratic variation y^2 for increasing number of valuation intervals",xlab="Number of valuation intervals",ylab="Quadratic variation quadratic function")

quad_var_siny=function(x){return(quad_variation(1,2,x,function(y){return(sin(y))}))}
plot(x_vector,sapply(x_vector,quad_var_siny),type="l",main="quadratic variation sin(y) for increasing number of valuation intervals",xlab="Number of valuation intervals",ylab="Quadratic variation sine function")
```

Functions for which the quadratic variation it zero can be integrated. It turns out that the quadratic variation of the Brownian motion over the interval $[0,T]$ is not zero but $T$, we will denote the quadratic variation in this case as $[B]_t=T$. This means that this process is not differentiable and can also not be integrated in the classical sense. More generally this will apply to practically all stochastic processes in finance, as these will be a combination of a deterministic and stochastic process. It will be discussed in the next section how the notion of the classical integral can be extended for this setting.

```{r}

bm_path=function(n){
  
  bm_vector=c(0)
  last_val=0
  
  for(i in 1:n){
    last_val=last_val+rnorm(1)*(1/sqrt(n))
    bm_vector<-c(bm_vector,last_val)
  }
  
  return(bm_vector)
}

quad_bm_vec=c()

for(i in x_vector){
  quad_bm=sum(diff(bm_path(i))^2)
  quad_bm_vec<-c(quad_bm_vec,quad_bm)
}

plot(quad_bm_vec, type="l",main="Quadratic variation plot BM")
abline(h=1,col="red")

```

## Stochastic differential equations and stochastic integrals 

A typical stochastic differential equation (sde) is of the following form:
$$  dX_t = a(X_t,t) dt + b(X_t,t)dW_t  $$
Note here that the first part is deterministic, while the second part is stochastic. To get a better understanding of this equation, it is good to view the the process $W_t$ as a noise term. Such a noise term should have some desired properties like independent increments and stationarity. There is no proper stochastic process that satisfies these properties and this process can not have continuous paths. Continuing, we could write:
$$  \Delta X_{t_k} = a(X_{t_k},t_k) \Delta t_k + b(X_{t_k},t_k)W_{t_k} \Delta t_k  $$
It turns out that the process $W_{t_k} \Delta t_k$ has stationary independent increments with mean zero and is the Brownian motion $B_t$. As a result we are interested in the limiting case of the following sum and whether it exists:
$$ \sum_k b(X_{t_k},t_k)W_{t_k} \Delta t_k $$
The technicalities will not be discussed here, however the key here is to examine this type of sum for so-called elementary functions which take on a single value $e_k$ over a subinterval $[t_k,t_{k+1}]$. This results in a sum of the following form:
$$ \sum_k e_k \Delta B_k $$

The more extensive cases can be constructed as a limiting case of such sums, with of course some technicalities, like for example: 
- It is for example not straightforward on which point the function $b(X_{t_k},t_k)W_{t_k}$ should be evaluated. In case of the Ito integral the left end point is evaluated.
- As this series is stochastic in nature, one is interested in the concept of convergence in $L^2$ and  probability rather than classical convergence.
The stochastic integral itself is stochastic in nature and follows a distribution, it converges to a limit (if it exists) but will also have a variance around this value (different simulations yield different outcomes).

Below we look at a few stochastic integrals. Note that R contains packages to numerically evaluate stochastic integrals.

```{r}
require(Sim.DiffProc)

#Identity function with respect to Brownian motion (BM)
set.seed(1001)
BM_paths=BM(N=1000,M=1000,T=2) #Separate BM paths are put in columns
diff_paths=apply(BM_paths,2,diff)
mean(apply(diff_paths,2,sum)) #Check mean
sd(apply(diff_paths,2,sum)) #Check sd, should approximate 

#BM wrt BM
#First evaluate it numerically
mean(apply(diff_paths*BM_paths[1:1000,],2,sum))
var(apply(diff_paths*BM_paths[1:1000,],2,sum))
#Now evaluate using the Sim.DiffProc package
set.seed(1001)
f <- expression( w )
summary(st.int(f,type="ito",M=1000,lower=0,upper=2))

#Quadratic BM wrt BM
#Numerical evaluation gives following
mean(apply(diff_paths*(BM_paths[1:1000,])^2,2,sum))
var(apply(diff_paths*(BM_paths[1:1000,])^2,2,sum))
#Now evaluate using the Sim.DiffProc package
set.seed(1001)
f <- expression( w^2 )
summary(st.int(f,type="ito",M=10000,lower=0,upper=2))
```
## Useful relationship and Ito's Lemma

Above we have numerically evaluated some integrals, we can also do this analytically by using some theoretical tools. Specifically we will discuss Ito's Lemma.

First let's look at core integral $\int_{0}^{T} W_t dW_t$. If we approximate this integral as a discrete sum of terms $(W_{t_k}(W_{t_{k+1}}-W_{t_k}))$. We will not evaluate this integral here, but in determining the analytical limit of this term, the sum 
$\sum_k (W_{t_{k+1}}-W_{t_k}))^2$ is important. It can be shown that 
$$\sum (W_{t_{k+1}}-W_{t_k}))^2 \rightarrow T $$
As a result it follows that:
$$\int_{0}^{T} W_t dW_t=\frac{1}{2}(W^2_T-T) $$
We now know that the mean of this integral is $\frac{1}{2}E(W^2_t-T)=\frac{1}{2}(T-T)=0$, while the variance is $Var(\frac{1}{2}(W^2_t-T))=\frac{1}{4}E(W^2_t-T)^2$. Using that $EW^4=3T^2$ the variance can be written as $\frac{1}{4}(2T^2)=\frac{1}{2}T^2$. For the numerical integral that we had evaluated, $T$ was 2 which results in a variance of $2$.

More generally it can be shown that the following (recurrence) relationship holds:
$$\int_{0}^{T} W^p_t dW_t=\frac{1}{p+1}(W_T^{(p+1)}-W_0^{(p+1)})-\frac{p-1}{2}\int_{0}^{T} W^{(p-1)}_t dW_t $$
So note that by working on these expression one can reach results analytically but it can become a mess quickly for more complicated integrals. 

Ito's lemma provides a tool in order to understand the behavior of (more complicated) sde's and subsequently stochastic integrals. Suppose now that we have a twice differentiable function $f$ and want to determine $df(S_t)$ for a stochastic process $S_t$, than we can not simply use the classic chain rule due to the stochastic component. In this case Ito's lemma can be used which can be seen as a generalization of the chain rule and is given by:
$$df(S_t)=f'(S_t)dS_t+\frac{1}{2}f''(S_t)d[S]_t$$
Here $[S]_t$ gives the quadratic variation of the stochastic process $S_t$ and is non-zero as we are dealing with a stochastic process. This second term is therefore an addition compared to the classical rule. Now let's look at two stochastic integrals that we had evaluated numerically to see Ito's lemma in practice.
Look at $\int W_tdW_t $ in which case $f(x)=x$, filling this in Ito's lemma gives:
$$dW_t=f'(S_t)dS_t+\frac{1}{2}f''(S_t)d[S]_t$$
Now let's look at a straightforward example in which we have $f(x)=x^2$
In this case we will obtain for a Brownian motion process:
$$dW^2_t=2W_tdW_t+dt$$
We can use this relationship in order to break down the integral of $dW^2_t$ in simpler integrals. Similarly we can use it to understand behavior of sde's, a famous example is in case we look at log returns for a Stock price process which will be seen later on in this document.

## Using R to simulate SDEs and SPs

The package Sim.DiffProc that we have used before contains many functions to examine SDEs and stochastic processes as we will demonstrate below.

```{r}
require(Sim.DiffProc)

#Function GBM simulates a Geometric Brownian Motion
set.seed(1001)
gbm<-GBM(N=250,M=100000,x0=100,t0=0,T=1,theta=0.01,sigma=0.6)
plot(apply(gbm,1,mean),type="l")

#We can do the same by solving the corresponding SDE and simulating the stochastic process that is the solution of this SDE. The function snssde1d can be used for solving (one-dimensional) sdes. The package also contains functions for higher dimensions. 

#In order to obtain a GBM, now look at a stock price process ie s_t=mu*s_t*dt+sigma*s_t*ds_t
mu=0.01
#Note that theta here gives the sd parameter, while it gave the mean parameter in the GBM function, be careful with this distinction.
theta=0.6
f <- expression( (mu*x) ) #deterministic part of the SDE
g <- expression( theta*x ) #stochastic part of the sde
#The function snssde1d has a lot of arguments and provides different options, we will look at type="ito", method="euler"
set.seed(1001)
sim <- snssde1d(drift=f,diffusion=g,x0=100,M=100000,N=250,t0=0,T=1,type="ito",method="euler")
plot(apply(sim$X,1,mean),type="l")

#Similarly the function snssde1d can be used for other sdes.
```

## H2: Valuation of financial derivatives

One of the main objectives in financial engineering is to find a fair price for derivatives, i.e. the price on which both parties agree. A derivative is a contract that derives its value from an underlying (reference) asset, in deriving the fair value of a derivative it is therefore necessary to model the value process of this asset. We will initially consider an stock whose value at time $t$ is denoted by $S_t$.

## Arbitrage

Arbitrage is a crucial concept in financial engineering. Aritrage is the practice of taking advantage of price differences in different markets. In the presence of arbitrage investors can make a risk-free profit by employing the proper trading strategy. Let's look at two variants of arbitrage:
- Instant gain: Think about selling a certain amount of gold in one market and simultaneously selling this amount in a different market for a higher price.
- Replication of payouts: In this case advantage is taken in price differences between a contract and replicating portfolio at a certain point in time. A replicating portfolio is a portfolio of financial instruments that replicates the cashflows of a contract. As a result, the value of the contract at all times needs to equal the value of the portfolio. An arbitrage opportunity arises when this is not the case.

## Geometric Brownian motion

As noted earlier the stock price $S_t$ can be modeled as $ dS_t=\mu S_t dt +\sigma S_t dW_t $, a process that satisfies this equation is called a Geometric Brownian Motion (GBM). As the stock price can not become negative in practice, the quantity $ln(S_t)$ is examined in order to model the log return. Using Ito's formula it can be obtained that the following equation is satisfied $ ln\left( \frac{S_t}{S_0} \right) = \left( \mu - \frac{\sigma^2}{2} \right)t + \sigma W_t $. From this equation it can be seen that the log return follows a
normal distribution and so the stock process follows log-normal distribution.

```{r}
#As seen before we can use the package Sim.DiffProc to simulate a GBM
require("Sim.DiffProc")
set.seed(1001)
plot(GBM(N=1000,T=1,t0=0,x0=100,theta=0.1,sigma=0.2),main="GBM simulation")
```

## Call and put options

An European call option ($C_t$) gives the option, and not the obligation, to buy the underlying asset at maturity ($T$) for a pre-agree price ($K$), known as the strike price. The value of the European call option at maturity will therefore be $max\{S_T-K,0\}$.
Similarly the European put option ($P_t$) gives the right to sell the underlying asset for a certain strike price. The value of the European put option at maturity will therefore be $max\{K-S_T,0\}$. We will assume they depend on the following variables $ S_t,K,T,\sigma,r $.
American call and put options, denoted by $c_t$ and $p_t$ respectively, are similar but can also be exercised at any time before maturity. It can be shown however that only in the case of the put option it is worthwhile to exercise early as the call option provide all the advantages of the underlying asset while it protects against downward movements. 

## Binomial Tree Model

We will assume that the underlying asset of the derivatives is a stock, whose value at time $t$ is denoted by $S_t$. For now we will look at a stock of which the value is given by $S_n$ at discrete times $n$ and look at a derivative that has a value $C(S_n)$ at maturity. For convenience it is best to assume this contract can only be exercised at maturity.

We model the stock price as a (discrete) binomial tree. In the simplest case we look at a one period model so that $S_1$ is either equal to $uS_0$ with probability $p$ or $dS_0$ with probability $1-p$, for $u>1>d$ representing an increase and decrease of the stock price respectively. Additionally we assume that the one period interest rate is given by $r$. This all means that $E_p(S_1)=puS_0+(1-p)dS_0$, using the measure $p$. Now by switching to the measure $q=\frac{e^r-d}{u-d}$ we will obtain that 
$$ E_q(e^{-r}S_1)=e^{-r}\left(\frac{e^r-d}{u-d}uS_0+\frac{u-e^r}{u-d}dS_0\right)=e^{-r}S_0\left(\frac{ue^r-de^r}{u-d}\right)=S_0  $$
Furthermore it can be shown that the value of the contract at time 0 will be given by:
$$ C(S_0)=e^{-r}E_q(C(S_1))$$
More generally for a $N$ period model it can be shown that $$ C(S_0)=e^{-rN}E_q(C(S_1))$$

It can be shown that the fair value of a derivative can be obtained by discounting the expected future value of the contract using the measure $q$. The measure $q$ is an important measure and is known as the risk-neutral measure, so while the different scenarios are constructed using the real-world measure $p$, for pricing one needs to switch to the risk neutral world.

## Value of European and American call and put options 

In this section we will value European and American call options.

```{r}
#Construct a Stock Price Binomial Tree
stock_binom_tree=function(S0,N,mu,delta,sigma){
  up=exp(mu*delta+sigma*sqrt(delta))
  down=exp(-(mu*delta+sigma*sqrt(delta)))
  stock_matrix=matrix(rep(0,(N+1)*(N+1)),(N+1),(N+1))
  stock_matrix[N+1,1]=S0
  
  #Multiply bottom row
  for(j in 2:(N+1)){
    stock_matrix[N+1,j]=stock_matrix[N+1,j-1]*down
  }
  
  #Obtain other rows
  for(j in 2:(N+1)){
    for(i in 1:(j-1)){
      #cat("i is:",i,"j is:",j)
      stock_matrix[(N+1)-i,j]=stock_matrix[(N+1)-i+1,j-1]*up
    }
  }
 
  return(stock_matrix) 
}

#Construct an option valuation tree (using the stock price binomial tree in previous function)
option_binom_tree=function(S0,N,mu,delta,sigma,K,r,type){
  
  stock_matrix=stock_binom_tree(S0,N,mu,delta,sigma)
  option_matrix=matrix(rep(0,(N+1)*(N+1)),(N+1),(N+1))
  
  if(type=="call"){
    option_matrix[,N+1]=pmax(stock_matrix[,N+1]-K,0)
  }else if(type=="put"){
    option_matrix[,N+1]=pmax(K-stock_matrix[,N+1],0)
  }else{
    print("Supplied type is invalid")
    stop()
  }
  
  up=exp(mu*delta+sigma*sqrt(delta))
  down=exp(-(mu*delta+sigma*sqrt(delta)))
  q=(exp(r*delta)-down)/(up-down)
  
  for(j in N:1){
    for(i in 1:j){
      option_matrix[(N+2)-i,j]=exp(-r*delta)*((1-q)*option_matrix[(N+2)-i,j+1]+q*option_matrix[(N+2)-i-1,j+1])
    }
  }
  
  #Obtain option value as option_matrix[N+1,1]
  return(option_matrix) 
}

#Black Scholes function
Black_Scholes=function(S0,K,r,sigma,T,type){
  d1=(log(S0/K)+(r+0.5*sigma^2)*T)/(sigma*sqrt(T))
  d2=d1-sigma*sqrt(T)
  call=S0*pnorm(d1)-K*exp(-r*T)*pnorm(d2)
  put=K*exp(-r*T)*pnorm(-d2)-S0*pnorm(-d1)
  if(type=="call"){
    return(call)
  }
  else if(type=="put"){
    return(put)
  }
  else{
    print("Supplied type is invalid")
    stop()
  }
}

#We now perform an option valuation for the below parameters
S=100
K=110
r=0.02
sigma=0.3
mu=0.1
T=0.25
N=2000

#Black Scholes value
BS_call_price=Black_Scholes(S,K,r,sigma,T,"call")

#Binomial tree valuation
binom_est_vector=c()
N_values=seq(100,5100,500)

for(i in N_values){
  new_est=option_binom_tree(S,i,mu,T/i,sigma,K,r,"call")[i+1,1]
  binom_est_vector=c(binom_est_vector,new_est)
}

#Plot to show that the increase in simulation steps (or reversely the step size) leads to a more accurate option price valuation. 
plot(N_values,binom_est_vector,ylim=c(2,3),main="Binomial tree call option pricing for increasing number of steps",xlab="Number of steps in tree (for given T)",ylab="option price")
abline(h=BS_call_price,col="red")
#Notice that the convergence is slow, the binomial tree method requires a lot of calculation time. The advantage is that it is a flexible approach that can be used in cases where no analytical formula exists or is difficult to derive. 

#Next we implement a function that can both handle European and Americanplot(N_values,binom_est_vector,ylim=c(13,14),main="Binomial tree call option pricing for increasing number of steps",xlab="Number of steps in tree (for given T)",ylab="option price")
gen_option_binom_tree=function(S0,N,mu,delta,sigma,K,r,opt_type="call",type="European"){
  
  stock_matrix=stock_binom_tree(S0,N,mu,delta,sigma)
  option_matrix=matrix(rep(0,(N+1)*(N+1)),(N+1),(N+1))
  
  up=exp(mu*delta+sigma*sqrt(delta))
  down=exp(-(mu*delta+sigma*sqrt(delta)))
  q=(exp(r*delta)-down)/(up-down)
  
  if(opt_type=="call"){
    option_matrix[,N+1]=pmax(stock_matrix[,N+1]-K,0)
    
      if(type=="European"){
        for(j in N:1){
          for(i in 1:j){
            option_matrix[(N+2)-i,j]=exp(-r*delta)*((1-q)*option_matrix[(N+2)-i,j+1]+q*option_matrix[(N+2)-i-1,j+1])
          }
        }
      } else if(type=="American"){
         for(j in N:1){
          for(i in 1:j){
            option_matrix[(N+2)-i,j]=max(stock_matrix[(N+2)-i,j]-K,exp(-r*delta)*((1-q)*option_matrix[(N+2)-i,j+1]+q*option_matrix[(N+2)-i-1,j+1]))
          }
        }
      }else{
        print("Supplied type is invalid")
        stop()
      }
    
  }else if(opt_type=="put"){
    option_matrix[,N+1]=pmax(K-stock_matrix[,N+1],0)
    
      if(type=="European"){
        for(j in N:1){
          for(i in 1:j){
            option_matrix[(N+2)-i,j]=exp(-r*delta)*((1-q)*option_matrix[(N+2)-i,j+1]+q*option_matrix[(N+2)-i-1,j+1])
            }
          }
      }else if(type=="American"){
          for(j in N:1){
            for(i in 1:j){
              option_matrix[(N+2)-i,j]=max(K-stock_matrix[(N+2)-i,j],exp(-r*delta)*((1-q)*option_matrix[(N+2)-i,j+1]+q*option_matrix[(N+2)-i-1,j+1]))
          }
        }
      }else{
          print("Supplied type is invalid")
          stop()
      }
    }
  
    #Obtain option value as option_matrix[N+1,1]
  return(option_matrix) 
}

#Now note that the American call option (for a non-dividend paying stock) gives the same price as the European call option. This has to do with the option also providing the same benefits with stock price increases, while it provides protection for downward movement.
#N=2000 is a safe choice for the amount of calculational time.
cat("European call option price:",round(gen_option_binom_tree(S,N,mu,T/N,sigma,K,r,opt_type="call",type="European")[(N+1),1],2))
cat("American call option price:",round(gen_option_binom_tree(S,N,mu,T/N,sigma,K,r,opt_type="call",type="American")[(N+1),1],2))

#For the European and American put options we obtain different prices as can be seen below, the American option will be more expensive as it provides the investor with a choice option. This additional option is worth more than zero even if the stock doesn't pay dividend.
cat("European put option price:",round(gen_option_binom_tree(S,N,mu,T/N,sigma,K,r,opt_type="put",type="European")[(N+1),1],2))
cat("American put option price:",round(gen_option_binom_tree(S,N,mu,T/N,sigma,K,r,opt_type="put",type="American")[(N+1),1],2))
```

##Interest rate instruments and derivatives

In this section we will use the binomial pricing approach in order to do pricing of interest rate instruments and derivatives. In doing this we will apply an interest rate lattice, rather than a flat interest rate or (deterministic) curve.

```{r}
#We create a interest rate lattice. Note that we can generate this lattice with certain parameters like is done in the Ho-Lee model or the Black-Toy-Derman model but we will fill it in a similar way as was done with the stock price lattice. Also the focus is here more on pricing Instruments and not so much on modeling the interest rate lattice.
interest_binom_tree=function(N,r0,up,down){

  int_matrix=matrix(rep(0,(N+1)*(N+1)),(N+1),(N+1))
  int_matrix[N+1,1]=r0
  
  #Multiply bottom row
  for(j in 2:(N+1)){
    int_matrix[N+1,j]=int_matrix[N+1,j-1]*down
  }
  
  #Obtain other rows
  for(j in 2:(N+1)){
    for(i in 1:(j-1)){
      int_matrix[(N+1)-i,j]=int_matrix[(N+1)-i+1,j-1]*up
    }
  }
 
  return(int_matrix) 
}

#Zero-coupon Bond Pricing: We first start by looking at the fair price for zero-coupon bond using a term strucure lattice. We will subsequently use this bond as underlying for our interest rate derivatives later in this section.
zcbond_binom_tree=function(N,r0,up,down,q,F){
  
  int_matrix=interest_binom_tree(N,r0,up,down)
  bond_matrix=matrix(rep(0,(N+1)*(N+1)),(N+1),(N+1))
  
  #Fill last column
  for(i in 1:(N+1)){
    bond_matrix[i,N+1]=F
  }
  #Fill bond matrix moving backwards
  for(i in N:1){
    for(j in 1:i){
      disc<-1/(1+int_matrix[(N+2)-j,i])
      bond_matrix[(N+2)-j,i]=disc*(q*bond_matrix[(N+2)-(j+1),(i+1)]+(1-q)*bond_matrix[(N+2)-j,(i+1)])
    }
  }
  
  return(bond_matrix)
}

#We now value a zero-coupon bond with the following parameters (as also seen in the above function).
N=10
r0=0.05
up=1.1
down=0.9
q=0.5
F=100
K=80

#Zero coupon bond price for above parameters
zcbond_tree<-zcbond_binom_tree(N,r0,up,down,q,F)
zcbond<-zcbond_tree[(N+1),1]
cat("Considered zero-coupon bond has at time 0 a value of:",round(zcbond,2))

#Next we we look at various interest rate derivatives on the zero-coupon bond that we have valued.

#Call-option: Most obvious derivatives to consider first are probably call options. We will examine American call options below. Note that the maturity of this contract can differ from the maturity of the underlying bond. The same will hold for the other considered derivatives later on.
zcbond_acall_tree=function(F,n,q,K,int_matrix,asset_tree){
  
  adim<-nrow(asset_tree)
  
  #Rescale the asset and interest rate matrices
  int_matrix_rs<-int_matrix[(adim-n):adim,1:(n+1)]
  zcbond_tree_rs<-asset_tree[(adim-n):adim,1:(n+1)]
  option_matrix=matrix(rep(0,(n+1)*(n+1)),(n+1),(n+1))
  option_matrix[,n+1]=pmax(zcbond_tree_rs[,(n+1)]-K,0)

  for(j in n:1){
    for(i in 1:j){
      disc<-1/(1+int_matrix_rs[(n+2)-i,j])
      option_matrix[(n+2)-i,j]=max(zcbond_tree_rs[(n+2)-i,j]-K,disc*((1-q)*option_matrix[(n+2)-i,j+1]+q*option_matrix[(n+2)-i-1,j+1]))
          }
  }
  
  return(option_matrix)
}

#We now value an American call option, with a maturity of 6 years, on the zero-coupon bond that we had valued earlier using the function that we have defined above.
N=10
r0=0.05
up=1.1
down=0.9
q=0.5
F=100
K=80

int_matrix<-interest_binom_tree(N,r0,up,down)
asset_tree<-zcbond_binom_tree(N,r0,up,down,q,F)
N_opt=6
zcbond_acall=zcbond_acall_tree(F,N_opt,q,K,int_matrix,asset_tree)[N_opt+1,1]
cat("Considered American call option on zero-coupon bond has value:",round(zcbond_acall,2))

#Forwards: Forward pricing is relatively simple to implement as we need to do a rescaling based on the term structure lattice.
for_pricing=function(N_for,N_asset,r0,up,down,q,F){
  
  asset_val<-zcbond_binom_tree(N_asset,r0,up,down,q,F)[(N_asset+1),1]
  forward_factor=zcbond_binom_tree(N_for,r0,up,down,q,F)[(N_for+1),1]/F
  forward_value=asset_val/forward_factor

  return(forward_value)
}

#We consider a forward contract that matures at T=4, while the zc_bond maturity is at T=10.
r0=0.05
up=1.1
down=0.9
q=0.5
F=100
N_asset<-10
N_for<-4

asset_val<-zcbond
for_val<-for_pricing(N_for,N_asset,r0,up,down,q,F)
cat("Considered forward contract on zero-coupon bond has at time 0 a value of:",round(for_val,2))

#Futures: Futures are similar to forwards but will yield a slightly different price due to differences in the characteristics of both products (i.e. due to daily margin settling).
fut_pricing=function(N_fut,N_asset,r0,up,down,q,F){
  
  fut_matrix<-matrix(rep(0,(N_fut+1)*(N_fut+1)),(N_fut+1),(N_fut+1))
  fut_matrix[,N_fut+1]<-zcbond_binom_tree(N_asset,r0,up,down,q,F)[(N_asset-N_fut):N_asset+1,N_fut+1]
  
  for(j in N_fut:1){
    for(i in 1:j){
      fut_matrix[(N_fut+2)-i,j]=q*fut_matrix[(N_fut+2)-i-1,j+1]+(1-q)*fut_matrix[(N_fut+2)-i,j+1]
          }
  }

  return(fut_matrix[N_fut+1,1])
}

#We consider a futures contract that matures at T=4, while the zc_bond maturity is at T=10.
r0=0.05
up=1.1
down=0.9
q=0.5
F=100
N_asset<-10
N_fut<-4

asset_val<-zcbond
fut_val<-fut_pricing(N_fut,N_asset,r0,up,down,q,F)
cat("Considered futures contract on zero-coupon bond has at time 0 a value of:",round(fut_val,2))

#Swap contract: We look at a (fixed payer) swap, considering the earlier constructed interest rate binomial tree.
swap<-function(fixed,r0,N,up,down,q,F){
  
  int_matrix=interest_binom_tree(N,r0,up,down)
  swap_matrix<-matrix(rep(0,(N+1)*(N+1)),(N+1),(N+1))
  
  for(i in 1:(N+1)){
    swap_matrix[i,N+1]=(int_matrix[i,N+1]-fixed)/(1+int_matrix[i,N+1])
  }
  
  for(j in N:2){
    for(i in 1:j){
      swap_matrix[(N+2)-i,j]=(q*swap_matrix[(N+2)-i-1,j+1]+(1-q)*swap_matrix[(N+2)-i,j+1]+(int_matrix[(N+2)-i,j]-fixed))/(1+int_matrix[(N+2)-i,j])
          }
  }
  
  swap_matrix[N+1,1]=(q*swap_matrix[N,2]+(1-q)*swap_matrix[(N+1),2])/(1+int_matrix[N+1,1])
  
  return(swap_matrix)
}

#We consider a swap (fixed payer) contract that matures at T=10 with the interest rate binomial tree that we had constructed earlier.
N=10
r0=0.05
up=1.1
down=0.9
q=0.5
F=100

fixed=0.045
cat("Considered swap contract has at time 0 a value of:",round(swap(fixed,r0,N,up,down,q,F)[N+1,1],5))

#Swaption: Consider a swaption on earlier considered swap
swaption_binom_tree=function(fixed,r0,N,N_opt,up,down,q,F){
  
  #Construct swap and interest rate tree
  swap_matrix<-swap(fixed,r0,N,up,down,q,F)
  int_matrix=interest_binom_tree(N,r0,up,down)[((N-N_opt)+1):(N+1),1:(N_opt+1)]
  
  #Swaption matrix
  swaption_matrix=matrix(rep(0,(N_opt+1)*(N_opt+1)),(N_opt+1),(N_opt+1))
  
  #Fill last column
  swaption_matrix[,N_opt+1]=pmax(swap_matrix[(N-N_opt):N+1,N_opt+1],0)
  
  #Fill matrix moving backwards
  for(j in N_opt:1){
    for(i in 1:j){
      swaption_matrix[(N_opt+2)-i,j]=(q*swaption_matrix[(N_opt+2)-i-1,j+1]+(1-q)*swaption_matrix[(N_opt+2)-i,j+1])/(1+int_matrix[(N_opt+2)-i,j])
          }
  }

  return(swaption_matrix)
}

#Value a swaption (with T=5) on earlier swap that was considered.
N=10
r0=0.05
up=1.1
down=0.9
q=0.5
F=100
N_opt=5

cat("Considered swaption contract has at time 0 a value of :",round(swaption_binom_tree(fixed,r0,N,N_opt,up,down,q,F)[N_opt+1,1],5))

```

## Main references

* Financial Engineering and Risk Management (Part I and II), Columbia University
* 'Sim.DiffProc' package in R (version 4.5), AC Guidoum and K Boukhetala
* Stochastic Differential Equations (fifth edition), B Oksendal
